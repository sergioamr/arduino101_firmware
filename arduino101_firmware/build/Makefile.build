#
# Copyright (c) 2016, Intel Corporation
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
# 
# 3. Neither the name of the copyright holder nor the names of its
# contributors may be used to endorse or promote products derived from this
# software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

# =============================================================================
# Build a target in the specified source directory
# Usage:
# 	make -f Makefile.build SRC=<SRC>          \
# 	                       OUT=<OUT>          \
# 	                       KCONFIG=<KCONFIG>  \
# 	                       INC_ROOT=<INC_ROOT>
# Where:
#  <SRC>        is the directory you want to build, relative from the tree top
#  <OUT>        is the path to the out-of-tree build directory
#  <KCONFIG>    is the path to the Kconfig file (name included)
#  <INC_ROOT>   is the path to the root include directories
# =============================================================================

# This is the default target, that will eventually trigger everything
all:
	$(AT)true

ifndef SRC
$(error No source directory (SRC) specified)
endif

ifndef OUT
$(error No output directory (OUT) specified)
endif

ifndef KCONFIG
$(error No Kconfig file (KCONFIG) specified)
endif

# If no include root path specfied, assume default
INC_ROOT ?= $(CURDIR)/include

# All targets added to the PHONY variable will end up in .PHONY
# DO NOT add targets that are actual files to this: if you want a target to be
# built everytime, add the predefined FORCE target below as a dependency
PHONY := FORCE

# =============================================================================
# Step 1: Load build configuration
#
# The build configuration for this specific directory is contained in:
# - the global configuration file generated by Kconfig
# - the specific Kbuild.mk file defining rules for this directory
# =============================================================================

# Reset Kconfig variables so
# 1) they have correct type
# 2) they do not inherit any value from the environment
obj-y :=
cflags-y :=

# Read Kconfig's configuration file
include $(KCONFIG)

# Concatenate OUT and SRC without the absolute path to the project
OUT_SRC := $(abspath $(OUT)/$(SRC:$(T)/%=%))

# Include local build configuration file if it exists, otherwise ignore
-include $(SRC)/Kbuild.mk

# =============================================================================
# Step 2: Check build configuration
#
# Evaluate what's to be done for that SRC based on what's in the obj-y
# variable populated by Kbuild.mk with the help of Kconfig's auto.conf
#
# The input of this phase is contained in:
# - obj-y:
#   A list of local object files and directories
#
# The output of this phase is contained in:
# - obj-y:
#   A list of objects and archives to be bundled into a built-in.a "thin" archive
#   which contains references to the original objects under this directory tree
# - subdir-obj-y:
#   A list of dir/built-in.a to be obtained as a result of the recursive
#   conditional build of each subdirectory of the current directory
# - subdir-y:
#   The actual list of subdirectories to descend into to produce subdir-obj-y
# =============================================================================

# First, identify if there are any directories specifed in obj-y that we need
# to descend into
__subdir-y	:= $(patsubst %/,%,$(filter %/, $(obj-y)))
subdir-y	+= $(__subdir-y)
subdir-y	:= $(sort $(subdir-y))

# Remove possible absolute project path prefix, as another absolute prefix will be added
obj-y		:= $(obj-y:$(T)/%=%)

# Next, update the list of objects, replacing any specified directory by the
# aggregated thin archive that will be produced when descending into it
obj-y		:= $(patsubst %/, %/built-in.a, $(obj-y))

# Remember the list of these aggregated archives, that will be used as a dependency
# to trigger the recursion into subdirectories
subdir-obj-y := $(filter %/built-in.a, $(obj-y))

# Prepend subdirs (absolute dirs are omitted) with the absolute SRC path
subdir-y := $(filter /%,$(subdir-y)) \
            $(addprefix $(SRC)/,$(filter-out /%,$(subdir-y)))

# Prepend the objects and archives with the actual build SRC
obj-y		:= $(addprefix $(OUT_SRC)/,$(obj-y))
subdir-obj-y := $(addprefix $(OUT_SRC)/,$(subdir-obj-y))

ifneq ($(VERBOSE),)
$(info Arduino101_Firmware kbuild processed: pwd=$(CURDIR) src=$(SRC) out=$(OUT:$(T)/%/kbuild=%))
$(info -   subdirs-y: $(subdir-y))
$(info -   obj-y: $(obj-y))
$(info -   subdir-obj-y: $(subdir-obj-y))
endif

# =============================================================================
# Step 3: Define rules to descend into subdirectories
# =============================================================================

# Tell make to descend into subdirs to build the corresponding archives
# Compilation flags specified using subdir-cflags-y are passed recursively
$(sort $(subdir-obj-y)): $(subdir-y) ;

PHONY += $(subdir-y)
$(subdir-y):
	@[ "$(VERBOSE)" ] && echo "Descending into directory $@" || true
	$(AT)$(MAKE) -f build/Makefile.build \
		SRC=$@ \
		OUT=$(OUT) \
		KCONFIG=$(KCONFIG) \
		INC_ROOT=$(INC_ROOT) \
		CFLAGS="$(CFLAGS) $(subdir-cflags-y)"

# =============================================================================
# Step 4: Define rules to build objects in this directory
# =============================================================================

# Include dependency files that may have been produced by a previous build
-include $(OUT_SRC)/*.d

# Compute CFLAGS to be applied on all files in this directory, based on:
# - the existing CFLAGS that may have been passed to us on the make command
# - the cflags-y and subdir-cflags-y defined in the local Kbuild.mk
# Note: per-file flags can also be set using the CFLAGS_<file>.o syntax
COMPUTED_CFLAGS := $(CFLAGS) $(subdir-cflags-y) $(cflags-y)
# We may not be compiling from the directory itself, so add it to the include
# search path, and prefix current dir if path is relative
COMPUTED_CFLAGS += -I$(if $(filter /%, $(SRC)),,$(CURDIR)/)$(SRC)
# Also add the top-level include directive
COMPUTED_CFLAGS += -I$(INC_ROOT)
# Also add the path to the global configuration header
COMPUTED_CFLAGS += -I$(OUT)/config
# Tell gcc to generate dependency files
COMPUTED_CFLAGS += -MD

# Create directory
$(OUT_SRC):
	@echo $(ANSI_RED)"[kMD]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)mkdir -p $@

# Build C files
$(OUT_SRC)/%.o: $(SRC)/%.c $(OUT_SRC)/c.flags
	@echo $(ANSI_RED)"[kCC]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)$(CC) $(COMPUTED_CFLAGS) $(CFLAGS_$(notdir $@)) -c -o $@ $<

# Build S file (assembly)
$(OUT_SRC)/%.o: $(SRC)/%.s $(OUT_SRC)/c.flags
	@echo $(ANSI_RED)"[kAS]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)$(CC) $(COMPUTED_CFLAGS) $(CFLAGS_$(notdir $@)) -c -o $@ $<

# Build S file (assembly with pre-processor)
$(OUT_SRC)/%.o: $(SRC)/%.S $(OUT_SRC)/c.flags
	@echo $(ANSI_RED)"[kAS+P]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)$(CC) $(COMPUTED_CFLAGS) $(CFLAGS_$(notdir $@)) -c -o $@ $<

# Create an aggregated thin archive
$(OUT_SRC)/built-in.a: $(obj-y) | $(OUT_SRC)
	@echo $(ANSI_RED)"[kAR]"$(ANSI_OFF) $(@:$(T)/%=%)
	$(AT)rm -f $@
	$(AT)$(AR) -rcT $@ $(obj-y)

# Remember CFLAGS used to compile files in this directory
$(OUT_SRC)/c.flags: $(KCONFIG) | $(OUT_SRC)
	$(AT)echo '$(COMPUTED_CFLAGS)' | cmp -s - $@ || echo '$(COMPUTED_CFLAGS)' > $@

# =============================================================================
# Step 5: Let's build
# =============================================================================

all: $(OUT_SRC)/built-in.a

.PHONY: $(PHONY)
